# cc3200_seismo
seismostation on cc3200 ucontroller
1. Работа программы переписана для работы на FreeRTOS
2. Изменен протокол на новый
3. Измерены размеры Кучи и стека в файле linker.cmd
4. Уменьшил размер кучи и памяти под буферы в RTOS. Размер кучи теперь 65535 Байт
5. Размер буфер под пинг или понг - 24000 байта максимум.
6. Перекомпилированы библиотеки fat_fs rtos и др.
7. Добавил поддержку WiFi - пока только функции подключения к AP
8. Добавил команду RESET_MCU
9. Сделал по прерыванию - собирает 4 данных только потом отправляет
10. В ini сделал размер буфера стека 2048 - было в 2 раза меньше - могло вызвать ошибку - размер файла не должен быть больше 2к!!!
11. изменил структуру каталогов - разбил по папкам: очень много файлов, неудобно.  
12. Изменил utils.h/utils.c на userfunc.* - иначе конфликтовали названия с системными файлами   
13. Lобавил расчет углов, но драйверы микросхем для сс3200 пока не написаны - не работает плата
14. Версию поменял на 5
15. Изменил названия файлов во избежании конфликтов с системными: spi, udma и пр.
16. Сделал децимацию "всегда" на 8. т.е для получения частоты 250 - запускаем на 2 кГц и прореживаем.
17. убрал из прерывания АЦП массив данных на стеке, перенес в статическую память.
18. Создаются объекты, который занимаются обработкой данных
19. Изменил ads131.c - фильтрация/децимация по 8-ми точкам.
20. В прерывании только сбор данных! 
21  Вернул ads131.c - в прерывании обработка данных, иначе сбоит прием/передача!
22. Сделал один файл для всех сенсоров, которые сидят на шине twi (i2c) - нет смысла для каждой микросхемы
    создавать отдельную задачу. Опрос проводится последовательно, раз в несколько секунд будет достаточно.
23. В файле TWI.c создал объект блокировки, пронаблюдать за созданием/удалением - возможна ошибка, 
    так как объект удаляется внутри неудаленной задачи
24. Поставил в UART размер приемного FIFO 2/8. Т.е. 4 байта
25. Убрал delay_ms и заменил на TaskDelay в конце каждой задачи
26. Заменил подсчет наносекунд в timertick.c
27. Уменьшил размер кучи и буферов ping-pong до 0x4000!
28. Так как появлся нормальный процессор - увеличил кучу до 64к. Для Ping-Pong сразу выделяется буфер 24000 байта
29. Сделал буферы статические для Ping-pong. Проверяю.
30. Сделал поток для заполнения кольцевого буфера - буфер заполняется не в прерывании
31. Выключение ненужных каналов ADS131
32. Добавил установку битов в GPS_STATE_t
33. Добавил команды управления SD картой: картридер и CPU
34. Максимальная длина строки в ini файле - 128 символов
35. Убрал "тестовый режим", так как он не использовался
36. Исправлена ошибка сенсоров - статусы не были готовы, а данные уже читалсиь
37. Cоздаю 1 раз объекты в ads131.c - иначе память фрагментируется и исчерпывается из-за этого!
37-a. Exception - невыровненный memcpy в модуле circbuf.c - в функции ADS131_get_pack->cb_read если включен TWI и SD карта
   вылетает на 75 элементе elem->start (75) - исправил 

38. Инициалитзация кольцебуфера в START
39. Поменял simple timer с TIMERA1 на TIMERA3
40. Инициализация обмена по порту сразу - если нет WiFi ранее завершалось ошибкой
41. Добавил обнаружение файла lock.fil  - для запуска по часам
42. В любом режиме определить имя станции и параметры подключения
43. Добавил функцию select в ожидании данных сокета для выхода из ожидаия, в случае разрыва соединения.
44. Переписал синхронизацию. Нужно понаблюдать в какой момент синхронизировать.
45. Записываю свой IP адрес в исходящем пакете поле device_id в структуре DEV_ID_h
46. Переделываю заголовки по новому требованию. Размер пакета с данными уменшен до 160 байт
47. Поменял NO_DATA на EMPTY. Команда RESET_MCU идет последней
48. Изменил поля структур, не проверено пока.
49. Написал тест по UDP - исправил получение по этому протоколу (была проверка ver, которая теперь меняется)
50. Объединил в select 2 сокета
51. Select работает криво - сделал 2 задачи для 2-х сокетов. Нужно проверить пересоединение при потере связи.
    одинаковый порт берется из задания на SD карте. UDP и TCP порты не перекрываются.
52. Переключение SD карты при передергивании USB кабеля
53. ? Добавил ожидание     while (Osi_twi_obj_lock() != OSI_OK); в sdreader.c - может привести к зависанию?
54. Отждельно UDP и TCP порты2
55. Убрал частоту АЦП 125 - увеличил sample_rate на единицу, чтобы не переделывать весь код:
	par.sps = (ADS131_FreqEn) adcp.sample_rate + 1;	/* частота - будет на 1 больше! */
***
	/* В командном режиме отмечаем что частота на ступень меньше - нет 125!  */
	pack->adc_freq = adc_pars_struct.sps_code - 1;	/* частота дискретизации */
***
	par->sample_rate -= 1;/* на 1 меньше */

56. Добавил     board_reset();    /* Сбросим плату */ - при заверение Normal
57. Добавил сброс платы при переключении кабеля к 52-му
58. Не запускать сетевые задачи если имя сети "None". Только COM порт. Сейчас нет WiFi сети 
59. Добавил временно TickHook - для миллисекундных таймаутов. Работает тока во FreeRTOS!!! файл timertick.c
60. Отключение USB кабеля проверяется в потоке для сенсоров каждую секунду.
61. Сбросим автомат при приеме COM порта, если длина не соответсвует команде  (START_PREVIEW и WRITE_PARAMS)
62. Если длина в команде не соответвует команде - сброс автомата приема в NET (START_PREVIEW и WRITE_PARAMS)
63. Упорядочить приоритеты прерываний. Определить более высокоприоритетные - таймер и АЦП
	ADS131 - LVL_1
	DMA    - LVL_1
	PPS    - LVL_2 - Прерывания PPS
	MTimer - LVL_3 - Главный таймер, считает время
	STimer - LVL_4 - Простой таймер, считает время пока не подстроен главный таймер
	COM    - LVL_5 - Прерывания по COM порту
64. Добавил подсчет дрифта: pAdc_hdr->Drift = timer_get_drift(); timertick.c - проверить эту функцию
65. Выходить с ошибкой если время старта и финиша "ушло". Перезагрузка!
    Если нет хотя бы 10 минут на запись! - сбросим плату 
66. Подавать разные PGA на каждый канал при работе CMD
67. PGA - подается прямое значение при командном режиме
68. Убрал отладочные сообщения: "Enter task" и "leave task"
69. Убрал отладочные сообщения при настройке АЦП - теперь пишутся в log
70. PGA в режиме Normal на 4 канала
71. Имя платы задается в командном файле как GNS'НОМЕРПЛАТЫ'._uart._tcp.local через mDNS
72. При отсылке сигнала в ver вставлять последовательно увеличивающиеся значения
73. Убрал функцию ADS131_get_data() - просто вызывала ADS131_get_pack()
74. pTxBuf->hdr.ver увеличивается в preview и сбрасывается при стопе измерений
75. Упорядочил приоритеты задач. Проверить, повысить вверх если необходимо!
76. Отладка идет только когда остановлены измерения
77. Поставил таймаут на прием по COM порту. 10 мс-прием заканивается или если длинная 
    команда или если команда не завершилась
78. в РЕЖИМЕ normal - оставил отладку
79. Добавил команду - выдать счетчики обмена 
80. Добавил очистку буферов в com_init()
81. Значение датчика напряжение увеличил втрое
82. Вывожу значение дрифта в тиках в поле tAcc
83. Моргаю битом self_test_on во время подстройки генератора по GPS
84. Исправил ошибки PGA - не выводилось значение каждого канала


Ошибки

- В UART не снимается ошибка OVERRUN! Если попадает в обработку этой ошибки - то ее 
  невозможно снять вообще!
- При перезагрузке выдергиванием кабеля, шина I2C остается в непонятном состоянии и устойства
  на ней не работают. Помогает только полное обесточивание платы.

Необходимо!

- Проверить синхронизацию часов. Фаза PPS подстраивается правильно, но само время не проверено
- поставить таймаут на чтение/запись/посылка команды на SD карту
   иначе при невозможности записать блок - задача подвисает. Должно возвращаться с ошибкой!
- Так как нет часов RTC - необходимо брат время с модуля GPS. Как только разберемся в правильной разводке GPS модуля.
   Сейчас при включении время GPS идёт с 1970 года
- Проверить значение датчика влажности
